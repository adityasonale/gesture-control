# -*- coding: utf-8 -*-
"""gesture.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15MSHeSPqIM4xTJR8gCuNDuKg8lvnsAYu
"""

import cv2
import mediapipe as mp
import hand_landmarker as hlm
import numpy as np
import pyautogui as pgui

"""Setting up Mediapipe"""

mpHands = mp.solutions.hands
mpDraw = mp.solutions.drawing_utils
hands = mpHands.Hands(
    static_image_mode=False,
    model_complexity=1,
    min_detection_confidence=0.75,
    min_tracking_confidence=0.75,
    max_num_hands=1)

"""Video Capturing"""

cap = cv2.VideoCapture(0)

screen_width,screen_height = pgui.size()

smoothening = 3
ploc_x,ploc_y = 0,0

curloc_x,curloc_y = 0,0

while cap.isOpened():
    # Read the next frame
    ret, frame = cap.read()
    cam_height, cam_width, channels = frame.shape
    # Flip the image(frame)
    frame = cv2.flip(frame, 1)

    # Frame Reduction
    frameR = 100

    # Convert BGR image to RGB image
    imgRGB = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

    # rectangle
    cv2.rectangle(frame, (frameR, frameR), (cam_width - frameR, cam_height - frameR), (0, 255, 0), thickness=2)

    # Process the RGB image
    results = hands.process(imgRGB)

    if results.multi_hand_landmarks:
        for handlms in results.multi_hand_landmarks:
            # print('hand_landmarks:', handlms)

            # printing Coordinates and Getting the coordinates of INDEX Finger
            # print(
            #     f'Index finger tip coordinates: (',
            #     f'{handlms.landmark[mpHands.HandLandmark.INDEX_FINGER_TIP].x * image_width}, '
            #     f'{handlms.landmark[mpHands.HandLandmark.INDEX_FINGER_TIP].y * image_height})'
            # )

            x_coor_index = handlms.landmark[mpHands.HandLandmark.INDEX_FINGER_TIP].x * cam_width
            y_coor_index = handlms.landmark[mpHands.HandLandmark.INDEX_FINGER_TIP].y * cam_height
        #-------------------------------------------------------------------------------------------

            # printing Coordinates and Getting the coordinates of MIDDLE Finger
            # print(
            #     f'Index finger tip coordinates: (',
            #     f'{handlms.landmark[mpHands.HandLandmark.MIDDLE_FINGER_TIP].x * image_width}, '
            #     f'{handlms.landmark[mpHands.HandLandmark.MIDDLE_FINGER_TIP].y * image_height})'
            # )

            x_coor_middle = handlms.landmark[mpHands.HandLandmark.MIDDLE_FINGER_TIP].x * cam_width
            y_coor_middle = handlms.landmark[mpHands.HandLandmark.MIDDLE_FINGER_TIP].y * cam_height
        #-------------------------------------------------------------------------------------------
            # coordinates of the cursor
            x3 = np.interp(x_coor_middle,(frameR,cam_width - frameR),(0,screen_width))
            y3 = np.interp(y_coor_middle,(frameR,cam_height - frameR),(0,screen_height))

            # coordinates of index finger
            x4 = np.interp(x_coor_index,(frameR,cam_width - frameR),(0,screen_width))
            y4 = np.interp(y_coor_index,(frameR,cam_height - frameR),(0,screen_height))

            distance = np.linalg.norm(np.array([x4, y4]) - np.array([x3, y3]))

            print(distance)

            curloc_x = ploc_x + (x3 - ploc_x)/smoothening
            curloc_y = ploc_y + (y3 - ploc_y)/smoothening

            if distance > 200:
                print("Click Mode...")
                pgui.click()

            else:
                print("Move Mode...")
                pgui.moveTo(curloc_x,curloc_y)

            ploc_x,ploc_y = curloc_x,curloc_y

            mpDraw.draw_landmarks(frame,handlms,mpHands.HAND_CONNECTIONS)
            cv2.circle(frame,(int(x_coor_index),int(y_coor_index)),10,(0,0,255),-1)  # -1 means fill the circle
            cv2.circle(frame,(int(x_coor_middle),int(y_coor_middle)),10,(0,0,255),-1)  # -1 means fill the circle

    cv2.imshow("Frame",frame)

    # Break the loop if the 'q' key is pressed
    if cv2.waitKey(25) & 0xFF == ord('q'):
        break

# Release the VideoCapture and close all windows
cap.release()
cv2.destroyAllWindows()